package klisp.parser.derivative

/**
 * A token tag indicates the "type" of a token.
 *
 * For tokens generated by a lexer, it's appropriate to use a string.
 *
 * For example: "ID", "INT", "LPAREN", "SEMICOLON"
 *
 * There should be a finite number of token tags, so "ID(foo)" is a bad
 * token tag.
 *
 * During the parsing process, special tokens called parsing markers may
 * take control of this field.
 */
internal typealias TokenTag = Any

/**
 * Parsers consume live streams of tokens (or objects that can be implicitly converted into them).
 *
 * A token is an individual lexeme.
 *
 * (In terms of context-free grammars, tokens are the terminals.)
 */
abstract class Token : Comparable<Token> {
    /**
     * @return true if this token represents a parsing marker.
     *
     * Parsing markers are special tokens that do not appear in input
     * strings; they only appear in parse strings to indicate the
     * structure of the parse.
     */
    abstract val isParsingMarker: Boolean

    /**
     * The class of this token.
     */
    protected open val clazz: String
        get() = this::class.toString()

    /**
     * The tag of this token.
     *
     * A token's tag indicates to which lexical class it belongs.
     *
     * Tokens consumed as input should have strings for their tags.
     *
     * Examples of good tags would be, "Identifier", "Integer", "String", ";", "(", ")".
     *
     * Parsing markers will have special tags.
     */
    abstract val tag: TokenTag

    protected abstract fun localCompare(other: Token): Int

    override fun compareTo(other: Token): Int {
        val c1 = clazz.compareTo(other.clazz)
        if (c1 != 0)
            return c1
        return localCompare(other)
    }
}

/**
 * Punctuation tokens.
 */
data class PunctToken(private val s: String) : Token() {
    override val isParsingMarker: Boolean = false
    override val clazz: String = s
    override val tag: TokenTag = s

    override fun localCompare(other: Token): Int {
        other as PunctToken
        return s.compareTo(other.s)
    }

    override fun hashCode(): Int = s.hashCode()
    override fun equals(other: Any?) = s == other
    override fun toString(): String = "[$s]"
}

/**
 * Symbol tokens.
 */
data class SymbolToken(private val s: String) : Token() {
    override val isParsingMarker: Boolean = false
    override val tag: TokenTag = "Symbol"

    override fun localCompare(other: Token): Int {
        other as SymbolToken
        return s.compareTo(other.s)
    }

    override fun hashCode(): Int = s.hashCode()
    override fun equals(other: Any?) = s == other
    override fun toString(): String = "'$s"
}

/**
 * String literal tokens.
 */
data class StringToken(private val s: String) : Token() {
    override val isParsingMarker: Boolean = false
    override val tag: TokenTag = "String"

    override fun localCompare(other: Token): Int {
        other as StringToken
        return s.compareTo(other.s)
    }

    override fun hashCode(): Int = s.hashCode()
    override fun equals(other: Any?) = s == other
    override fun toString(): String = "\"$s\""
}

/**
 * Integer tokens.
 */
data class IntToken(private val n: Int) : Token() {
    override val isParsingMarker: Boolean = false
    override val tag: TokenTag = "Int"

    override fun localCompare(other: Token): Int {
        other as IntToken
        return n.compareTo(other.n)
    }

    override fun hashCode(): Int = n.hashCode()
    override fun equals(other: Any?) = n == other
    override fun toString(): String = "$n"
}

/**
 * Boolean literal tokens.
 */
data class BooleanToken(private val b: Boolean) : Token() {
    override val isParsingMarker: Boolean = false
    override val tag: TokenTag = "Boolean"

    override fun localCompare(other: Token): Int {
        other as BooleanToken
        return b.compareTo(other.b)
    }

    override fun hashCode(): Int = b.hashCode()
    override fun equals(other: Any?) = b == other
    override fun toString(): String = b.toString()
}

/**
 * Character tokens.
 */
data class CharToken(private val c: Char) : Token() {
    override val isParsingMarker: Boolean = false
    override val tag: TokenTag = "Char"

    override fun localCompare(other: Token): Int {
        other as CharToken
        return c.compareTo(other.c)
    }

    override fun hashCode(): Int = c.hashCode()
    override fun equals(other: Any?) = c == other
    override fun toString(): String = "'$c'"
}

